#!/usr/bin/env python2
""" A visual respresentation of a Chord system.
"""

import enum
import math
import random
import argparse
import threading
import functools

import pygame

import packetlib

from chordlib import localnode
from chordlib import utils

from visualizer.window  import Window
from visualizer.math    import Vector


class DrawState(enum.Enum):
    NORMAL   = 0x1
    SELECTED  = 0x2


class VisualSprite(pygame.sprite.Sprite):
    SPRITES = []
    def __init__(self, listener):
        super(VisualSprite, self).__init__()

        VisualSprite.SPRITES.append(self)
        self.pos = Vector(0, 0)
        self._state = DrawState.NORMAL
        self.peer = VisualNode(self, listener)
        self.build()

    def build(self):
        """ Builds the peer sprite.

                   +------+
                  /        \
                 |          |
                  \        /
                   +------+
                  port = 50000
                  hash = 12345
        """
        circle_size = 40
        circle = pygame.Surface((circle_size, circle_size))
        circle.fill((255, 255, 255))
        line1 = FONT.render("hash=%d" % int(self.peer.hash),
                            True, (0, 0, 0))
        line2 = FONT.render("port=%d" % self.peer.chord_addr[1],
                            True, (0, 0, 0))

        padding = Vector(6, 6)
        fullsize = Vector(max(circle.get_width(), line1.get_width(),
                              line2.get_width()),
                          sum([x.get_height() for x in (circle, line1, line2)]))
        fullsize.x += padding.x
        fullsize.y += padding.y
        middle = Vector(circle).middle
        pygame.draw.circle(circle, self.color, middle.t, middle.x)
        self.image = pygame.Surface(fullsize.t)
        self.image.fill((255, 255, 255))
        self.image.blit(circle, (circle.get_width() / 2, padding.h / 2))
        self.image.blit(line1, (0, circle.get_height()))
        self.image.blit(line2, (0, circle.get_height() + line1.get_height()))

    def move(self, x, y):
        self.pos = Vector(x, y)

    def on_hover(self, window, x, y):
        lines = []
        for t in [
            ("peers=%d" % len(self.peer.peers)),
        ]:
            lines.append(FONT.render(t, True, (0, 0, 0)))

        y_offset = 0
        self.hovertext = pygame.Surface((max([s.get_width() for s in lines]),
                                         sum([s.get_height() for s in lines])))
        self.hovertext.fill((255, 255, 211))
        for line in lines:
            self.hovertext.blit(line, (0, y_offset))
            y_offset += line.get_height()

        window.blit(self.hovertext, (x + 20, y))

    def deselect(self):
        self.state = DrawState.NORMAL

    def select(self, selmode=None, prev=None):
        if self.state == DrawState.SELECTED:
            self.deselect()
        else:
            self.state = DrawState.SELECTED
            if prev and selmode == Mode.JOINER:
                print "Joining %s to %s." % (prev.peer, self.peer)
                func = lambda: prev.peer.join_ring(self.peer.chord_addr)
                threading.Thread(target=func).start()

            elif prev and selmode == Mode.LOOKUP:
                print "Looking up %d from %d" % (self.peer.hash, prev.peer.hash)
                def lookup_response(result, msg):
                    if msg is None:
                        print "The resulting node is itself:", result

                    else:
                        print "Lookup result was %s, %d" % (result, msg.mapped)

                func = lambda: prev.peer.lookup(self.peer.hash, lookup_response,
                                                None)
                threading.Thread(target=func).start()

    @property
    def rect(self):
        return pygame.Rect(self.pos.x, self.pos.y, self.image.get_width(),
                           self.image.get_height())

    @property
    def state(self): return self._state

    @state.setter
    def state(self, new_state):
        self._state = new_state
        self.build()

    @property
    def color(self):
        if self.state == DrawState.NORMAL:
            if self.peer.predecessor or self.peer.successor:
                return (0, 190, 0)
            else:
                return (230, 230, 0)
        elif self.state == DrawState.SELECTED:
            return (0, 0, 200)
        return (255, 0, 0)

    def update(self, window):
        self.peer.update(window)


class OutputLog(pygame.sprite.Sprite):
    """ Represents a text box, triggered on hovering a parent sprite.
    """
    def __init__(self, parent):
        super(OutputLog, self).__init__()
        self.font = pygame.font.SysFont("monospace", 14)
        header = self.font.render("message log:", True, (0, 0, 0))
        self.image = pygame.Surface((header.get_width(), header.get_height()))
        self.image.fill((255, 255, 200))
        self.image.blit(header, (0, 0))
        self.parent = parent
        self.pos = Vector(0, 50)

    def write(self, *lines):
        # Step 1: render each line individually.
        renders = []
        for line in lines:
            render = self.font.render(line, True, (0, 0, 0))
            renders.append(render)

        # Step 2: create a surface that will fit all of the new lines.
        #         calculate the longest line, and the total height of the new
        #         lines.
        new_height = sum(map(lambda x: x.get_height(), renders))
        new_width  = max(self.rect.w,
                         max(map(lambda x: x.get_width(), renders)))

        # Step 3: if the log is taller than the screen, remove old lines until
        #         it fits, simulating scrolling. we guesstimate the height of a
        #         line (because monospace).
        #
        #         we determine the number of lines we need to remove, and
        #         recreate the old log, cutting out from the top this number of
        #         lines.
        line_height = self.font.size("Q")[1]
        win_height = pygame.display.get_surface().get_height()
        cutout_px = (new_height + self.rect.h) - win_height
        if cutout_px > self.rect.h:
            raise ValueError("rendering the new lines takes more space "
                             "than the screen itself!")

        if cutout_px > 0:      # otherwise, we have enough space
            temp = pygame.Surface((new_height + (self.rect.h - cutout_px),
                                   new_width))
            temp.blit(self.image, (0, -cutout_px))
            self.image = temp

        new_height += self.rect.h
        new_image = pygame.Surface((new_width, new_height))

        # Step 4: draw the old log at the origin
        new_image.fill((255, 255, 200))
        new_image.blit(self.image, (0, 0))

        # Step 5: render each new line after the old log
        y_offset = self.rect.h
        for line in renders:
            new_image.blit(line, (0, y_offset))
            y_offset += line.get_height()

        self.image = new_image

    @property
    def rect(self):
        return pygame.Rect(self.pos.x, self.pos.y, self.image.get_width(),
                           self.image.get_height())

    def update(self, window):
        mouse_pos = pygame.mouse.get_pos()
        if self.parent.rect.colliderect(pygame.Rect(mouse_pos[0], mouse_pos[1],
                                                    1, 1)):
            window.blit(self.image, self.pos.t)


class VisualNode(localnode.LocalNode):
    """ Overloads peers to add visual indications of messages.

    We hook into the send and receive operations of all of the sockets for the
    peer:

        - sending requests: we create an outbound dot and move it towards the
                            target, storing the sequence number for later
                            association.

        - sending responses: we create an outbound dot towards the target that
                             deactivates automatically when it hits the target.
    """
    class DotType(enum.Enum):
        UNKNOWN = 0
        OUTBOUND_REQT = 1
        OUTBOUND_RESP = 2
        INBOUND_RESP  = 3
        INBOUND_REQT  = 4


    class Dot(pygame.sprite.Sprite):
        """ A visual representation of a message.

        It automatically deactivates when it collides with the target.

        :msg        a `MessageContainer` instance
        :dot_type   a `DotType` representing the type of dot
        :dest       the `VisualSprite` that we originated from
        :dest       a `VisualSprite` that we're trying to collide with
        """
        def __init__(self, msg, dot_type, src, dest):
            self.text = packetlib.message.MessageType.LOOKUP[msg.type]
            if msg.is_response: self.text += "r"

            self.msg = msg
            self.src = src
            self.dest = dest
            self.dtype = dot_type

            self.active = True
            self.pos = Vector(src.pos)
            self.pos.x += 40; self.pos.y += 20
            self.build()

            super(VisualNode.Dot, self).__init__()

        def build(self):
            """ Constructs the sprite contents.
            """
            self.font = pygame.font.SysFont("monospace", 24)
            text = self.font.render(self.text, True, (0, 0, 0))

            self.image = pygame.Surface((text.get_width(), 30))
            self.image.fill((255, 255, 0))
            self.image.blit(text, (0, 0))

        @property
        def rect(self):
            return pygame.Rect(self.pos.x, self.pos.y, 32, 32)

        def update(self):
            if not self.active: return
            delta  = pygame.math.Vector2(*self.dest.pos.t)
            delta += pygame.math.Vector2(40, 20)
            delta -= pygame.math.Vector2(*self.pos.t)
            delta.normalize_ip()
            delta *= 5

            self.pos.x += delta.x
            self.pos.y += delta.y

            if self.dest.rect.colliderect(self.rect):
                self.active = False

        @property
        def dest_addr(self):
            return self.dest.peer.chord_addr

        @staticmethod
        def from_bytes(src, sock, bs):
            msg = packetlib.message.MessageContainer.unpack(bs)
            if msg.is_response:
                dot_type = VisualNode.DotType.OUTBOUND_RESP
            else:
                dot_type = VisualNode.DotType.OUTBOUND_REQT

            if msg.type in (packetlib.message.MessageType.MSG_CH_PING,
                            packetlib.message.MessageType.MSG_CH_PONG):
                return None

            try:
                pkt = packetlib.chord.generic_unpacker(msg)
                src.log.write(repr(pkt))
            except:
                pass

            dest = VisualNode._resolve(sock)
            if not dest:
                import pdb; pdb.set_trace()
            dot = VisualNode.Dot(msg, dot_type, src.sprite, dest.sprite)
            src.dots.add(dot)
            return dot


    def __init__(self, sprite, listener):
        super(VisualNode, self).__init__(
            "%s:%d" % listener, listener,
            functools.partial(VisualNode.Dot.from_bytes, self))

        self.sprite = sprite
        self.dots = pygame.sprite.Group()
        self.log = OutputLog(self.sprite)

    def update(self, window):
        for p in self.peers:
            sprite = filter(lambda x: x.peer.chord_addr == p.chord_addr,
                            VisualSprite.SPRITES)[0]

            start = Vector(sprite.pos)
            start.x += 40; start.y += 20
            end = Vector(self.sprite.pos)
            end.x += 40; end.y += 20

            color, w = (0, 0, 0), 1

            if p in (self.successor, self.predecessor):
                color = self.sprite.color
                if self.sprite.state == DrawState.SELECTED:
                    w = 4

                if self.successor == self.predecessor:
                    color = (220, 0, 220)
                elif p is self.predecessor:
                    color = (220, 0, 0)

            pygame.draw.line(window.screen, color, start.t, end.t, w)

        self.dots.update()
        self.dots = pygame.sprite.Group(*filter(lambda x: x.active, self.dots))
        self.dots.draw(window.screen)
        self.log.update(window)

    @staticmethod
    def _finder(addr):
        for sp in VisualSprite.SPRITES:
            chaddr = sp.peer.chord_addr
            if chaddr[0] == addr[0] and chaddr[1] == addr[1]:
                return sp.peer

    @staticmethod
    def _resolve(sock):
        node = None
        try:
            # Either the remote is a `chord_addr` (if it accepted the
            # connection) or the remote is the `sockname` of a peer in another
            # peer.
            remote = sock.getpeername()
            for sprite in VisualSprite.SPRITES:
                if sprite.peer.chord_addr == remote:
                    return sprite.peer

                for peer in sprite.peer.peers:
                    if peer.peer_sock.getsockname() == remote:
                        return sprite.peer

        except Exception, e:
            print "_resolve() failure:", str(e)
        return node


def peer_at(peers, x, y):
    for peer in peers:
        if peer.rect.colliderect(pygame.Rect(x, y, 1, 1)):
            return peer
    return None

def get_selected(ring):
    sel = filter(lambda x: x.state == DrawState.SELECTED, ring)
    return sel[0] if sel else None


class Mode(enum.Enum):
    SELECT = 1
    JOINER = 2
    LOOKUP = 3

if __name__ == "__main__":
    pygame.init()

    FONT = pygame.font.SysFont("monospace", 24)

    quit = False
    clock = pygame.time.Clock()
    window = Window()
    ring = pygame.sprite.Group([
        VisualSprite(("localhost", 10000 + i)) for i in xrange(15)
    ])

    sprites = sorted(ring.sprites(), key=lambda x: int(x.peer.hash))
    dimension = min(window.size.w, window.size.h)
    radius = (dimension / 2) - (dimension * 0.05)
    for i, d in enumerate(xrange(0, 360, 360 / len(ring))):
        x = window.center.x + radius * math.cos(utils.rad(d))
        y = window.center.y + radius * math.sin(utils.rad(d))
        sprites[i].move(x, y)

    mode = Mode.SELECT
    mouse_pos = Vector(0, 0)
    while not quit:
        window.fill()
        ring.draw(window.screen)
        window.blit(FONT.render(repr(mode), True, (0, 0, 0)), (0, 0))

        for evt in pygame.event.get():
            if evt.type == pygame.QUIT:
                quit = True

            elif evt.type == pygame.KEYUP:
                if evt.key == pygame.K_q:
                    quit = True

                # Join mode -- allows you to connect the selected peer to the
                # next clicked peer.
                elif evt.key == pygame.K_j:
                    mode = Mode.JOINER

                # Cancel special modes / force select mode.
                elif evt.key in (pygame.K_ESCAPE, pygame.K_s):
                    mode = Mode.SELECT

                # Perform a value lookup.
                elif evt.key == pygame.K_l:
                    mode = Mode.LOOKUP

                # Print out the connected peers of a peer.
                elif evt.key == pygame.K_p:
                    sel = get_selected(ring)
                    if not sel: continue
                    print "All of the peers in %s are:" % sel.peer
                    print "  s", sel.peer.successor
                    print "  p", sel.peer.predecessor
                    for p in sel.peer.peers:
                        if p not in (sel.peer.successor, sel.peer.predecessor):
                            print "  -", p

                # Disconnect the selected node from the ring.
                elif evt.key == pygame.K_d:
                    sel = get_selected(ring)
                    if not sel: continue
                    print "Leaving %s from the ring." % sel.peer
                    threading.Thread(target=(
                        lambda sel=sel: sel.peer.leave_ring()
                    )).start()

                # Interconnect nodes randomly.
                elif evt.key == pygame.K_r:
                    peerlist = map(lambda x: x.peer, ring)
                    def connect_all():
                        connected = [random.choice(peerlist)]
                        unconnected = list(peerlist)
                        unconnected.remove(connected[0])

                        while unconnected:
                            peer = random.choice(unconnected)
                            root = random.choice(connected)

                            print "Joining peer %s to network via %s" % (peer, root)
                            unconnected.remove(peer)
                            peer.join_ring(root.chord_addr)
                            connected.append(peer)

                    conn_thread = threading.Thread(target=connect_all)
                    conn_thread.start()

            elif evt.type == pygame.MOUSEMOTION:
                mouse_pos = Vector(*evt.pos)

            elif evt.type == pygame.MOUSEBUTTONDOWN:
                if evt.button == 1:
                    sel = None
                    prevmode = mode
                    if mode in (Mode.JOINER, Mode.LOOKUP):
                        sel = get_selected(ring)
                        for peer in ring: peer.deselect()
                        mode = Mode.SELECT

                    for peer in ring:
                        mouse = pygame.Rect(evt.pos[0], evt.pos[1], 1, 1)
                        if peer.rect.colliderect(mouse):
                            peer.select(selmode=prevmode, prev=sel)
                        else:
                            peer.deselect()

        peer = peer_at(ring, mouse_pos.x, mouse_pos.y)
        if peer: peer.on_hover(window, mouse_pos.x, mouse_pos.y)

        ring.update(window)
        window.flip()
        clock.tick(30)
